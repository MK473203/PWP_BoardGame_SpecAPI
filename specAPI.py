import json
import requests
import threading
import time
import json
import pika
from flask import Response, Blueprint
from specAPI import BOARDGAME_SERVER, GAMES_HREF, MASON, RABBITMQ_BROKER_URL, workers, exit


"""
Overall system schema:

- One worker and exchange per game instance (Could perhaps be changed to multiple game instances per worker)
- Worker fetches game data from the main API every X seconds
- One queue per spectator
- Exchange name is the game uuid
- Queue name is randomly generated by the spectating client

"""

api_bp = Blueprint("api", __name__, url_prefix="")

class SpectatorWorker():

    def __init__(self, game_uuid: str):
        self.game_uuid = game_uuid
        self.game_url = BOARDGAME_SERVER + GAMES_HREF + game_uuid
        self.game_json = None
        self.connection = None
        self.channel = None
        self.client_recently_joined = False

        try:
            resp = requests.get(self.game_url, timeout=10)
        except requests.Timeout:
            self.log("Could not get response from server")
            self.game_found = False
            return

        if resp.status_code == 200:
            self.game_found = True
        else:
            self.game_found = False

    def __del__(self):
        self.log("Worker shut down successfully")

    def log(self, message):
        print("Worker " + self.game_uuid[0:5] + ": " + message, flush=True)

    def close(self):
        self.log("Shutting down")
        self.connection.close()
    """
    def on_join(self, _channel, basic_deliver, properties, body):
        self.client_recently_joined = True
    """
    def on_open(self, connection):
        self.log("Opening connection")
        self.channel = self.connection.channel()
        self.channel.exchange_declare(
            exchange=self.game_uuid,
            exchange_type="fanout"
        )
        """
        self.channel.queue_declare(queue="join_notifications")
        self.channel.basic_consume(
            queue="join_notifications", on_message_callback=self.on_join)
        """

    def run(self):
        self.log("Starting")
        self.connection = pika.BlockingConnection(parameters=pika.URLParameters(RABBITMQ_BROKER_URL))
        self.on_open(self.connection)
        while self.connection.is_open and not exit.is_set():

            resp = requests.get(self.game_url)

            if resp.status_code == 200:
                # If the game state has not changed there is no need to send it
                if resp.json() != self.game_json or self.game_json is None:
                    self.game_json = resp.json()
                    self.channel.basic_publish(
                        exchange=self.game_uuid,
                        routing_key="",
                        body=json.dumps(self.game_json)
                    )
                if self.game_json["result"] != -1:
                    # If the game has finished there probably won't be any updates
                    # so we can stop the worker
                    self.close()
                else:
                    time.sleep(0.5)
            else:
                self.log("ERROR " + resp.status_code +
                         ": Could not get game information")
                self.close()


@api_bp.route("/spectate/<string:game>")
def spectate_game(game):
    global workers

    worker = None

    for w, _ in workers:
        if w.game_uuid == game:
            worker = w
            break

    if worker is None:
        print("Worker not found for " + game + ". Creating a new worker")
        worker = SpectatorWorker(game)

    if worker.game_found:
        thread = threading.Thread(
            target=worker.run, name="Worker " + worker.game_uuid[0:5])
        thread.start()
        workers.append((worker, thread))

        resp = {}
        resp["@controls"] = {}
        resp["exchange"] = worker.game_uuid
        resp["@controls"]["amqp-url"] = RABBITMQ_BROKER_URL

        return Response(response=json.dumps(resp), status=200, mimetype=MASON)
    else:
        del worker
        resp = {}
        resp["status"] = "Game was not found"
        resp["@controls"] = {}

        return Response(response=json.dumps(resp), status=404, mimetype=MASON)
